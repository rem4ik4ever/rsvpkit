# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type Session {
  id: ID!
  user: User
  accessToken: String
  createdAt: DateTime
  userAgent: String
  ip: String
  updatedAt: DateTime
  expiresAt: DateTime
}

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input SessionWhereUniqueInput {
  id: ID
  accessToken: String
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  id: IDFilter
  user: UserWhereInput
  accessToken: StringFilter
  createdAt: DateTimeNullableFilter
  userAgent: StringFilter
  ip: StringFilter
  updatedAt: DateTimeNullableFilter
  expiresAt: DateTimeNullableFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input SessionOrderByInput {
  id: OrderDirection
  accessToken: OrderDirection
  createdAt: OrderDirection
  userAgent: OrderDirection
  ip: OrderDirection
  updatedAt: OrderDirection
  expiresAt: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input SessionUpdateInput {
  user: UserRelateToOneForUpdateInput
  accessToken: String
  createdAt: DateTime
  userAgent: String
  ip: String
  updatedAt: DateTime
  expiresAt: DateTime
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input SessionUpdateArgs {
  where: SessionWhereUniqueInput!
  data: SessionUpdateInput!
}

input SessionCreateInput {
  user: UserRelateToOneForCreateInput
  accessToken: String
  createdAt: DateTime
  userAgent: String
  ip: String
  updatedAt: DateTime
  expiresAt: DateTime
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type User {
  id: ID!
  name: String
  email: String
  password: PasswordState
  sessions(where: SessionWhereInput! = {}, orderBy: [SessionOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SessionWhereUniqueInput): [Session!]
  sessionsCount(where: SessionWhereInput! = {}): Int
  accounts(where: AccountWhereInput! = {}, orderBy: [AccountOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: AccountWhereUniqueInput): [Account!]
  accountsCount(where: AccountWhereInput! = {}): Int
  teamMember(where: TeamMemberWhereInput! = {}, orderBy: [TeamMemberOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TeamMemberWhereUniqueInput): [TeamMember!]
  teamMemberCount(where: TeamMemberWhereInput! = {}): Int
  currentTeam: Team
  events(where: EventWhereInput! = {}, orderBy: [EventOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: EventWhereUniqueInput): [Event!]
  eventsCount(where: EventWhereInput! = {}): Int
  emailConfirmedAt: DateTime
  avatarUrl: String
  createdAt: DateTime
  isAdmin: Boolean
}

type PasswordState {
  isSet: Boolean!
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
  sessions: SessionManyRelationFilter
  accounts: AccountManyRelationFilter
  teamMember: TeamMemberManyRelationFilter
  currentTeam: TeamWhereInput
  events: EventManyRelationFilter
  emailConfirmedAt: DateTimeNullableFilter
  avatarUrl: StringFilter
  createdAt: DateTimeNullableFilter
  isAdmin: BooleanFilter
}

input SessionManyRelationFilter {
  every: SessionWhereInput
  some: SessionWhereInput
  none: SessionWhereInput
}

input AccountManyRelationFilter {
  every: AccountWhereInput
  some: AccountWhereInput
  none: AccountWhereInput
}

input TeamMemberManyRelationFilter {
  every: TeamMemberWhereInput
  some: TeamMemberWhereInput
  none: TeamMemberWhereInput
}

input EventManyRelationFilter {
  every: EventWhereInput
  some: EventWhereInput
  none: EventWhereInput
}

input BooleanFilter {
  equals: Boolean
  not: BooleanFilter
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
  emailConfirmedAt: OrderDirection
  avatarUrl: OrderDirection
  createdAt: OrderDirection
  isAdmin: OrderDirection
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  sessions: SessionRelateToManyForUpdateInput
  accounts: AccountRelateToManyForUpdateInput
  teamMember: TeamMemberRelateToManyForUpdateInput
  currentTeam: TeamRelateToOneForUpdateInput
  events: EventRelateToManyForUpdateInput
  emailConfirmedAt: DateTime
  avatarUrl: String
  createdAt: DateTime
  isAdmin: Boolean
}

input SessionRelateToManyForUpdateInput {
  disconnect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  create: [SessionCreateInput!]
  connect: [SessionWhereUniqueInput!]
}

input AccountRelateToManyForUpdateInput {
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
  create: [AccountCreateInput!]
  connect: [AccountWhereUniqueInput!]
}

input TeamMemberRelateToManyForUpdateInput {
  disconnect: [TeamMemberWhereUniqueInput!]
  set: [TeamMemberWhereUniqueInput!]
  create: [TeamMemberCreateInput!]
  connect: [TeamMemberWhereUniqueInput!]
}

input TeamRelateToOneForUpdateInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
  disconnect: Boolean
}

input EventRelateToManyForUpdateInput {
  disconnect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  create: [EventCreateInput!]
  connect: [EventWhereUniqueInput!]
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  email: String
  password: String
  sessions: SessionRelateToManyForCreateInput
  accounts: AccountRelateToManyForCreateInput
  teamMember: TeamMemberRelateToManyForCreateInput
  currentTeam: TeamRelateToOneForCreateInput
  events: EventRelateToManyForCreateInput
  emailConfirmedAt: DateTime
  avatarUrl: String
  createdAt: DateTime
  isAdmin: Boolean
}

input SessionRelateToManyForCreateInput {
  create: [SessionCreateInput!]
  connect: [SessionWhereUniqueInput!]
}

input AccountRelateToManyForCreateInput {
  create: [AccountCreateInput!]
  connect: [AccountWhereUniqueInput!]
}

input TeamMemberRelateToManyForCreateInput {
  create: [TeamMemberCreateInput!]
  connect: [TeamMemberWhereUniqueInput!]
}

input TeamRelateToOneForCreateInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

input EventRelateToManyForCreateInput {
  create: [EventCreateInput!]
  connect: [EventWhereUniqueInput!]
}

type TeamMember {
  id: ID!
  user: User
  team: Team
  role: String
  removedAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input TeamMemberWhereUniqueInput {
  id: ID
}

input TeamMemberWhereInput {
  AND: [TeamMemberWhereInput!]
  OR: [TeamMemberWhereInput!]
  NOT: [TeamMemberWhereInput!]
  id: IDFilter
  user: UserWhereInput
  team: TeamWhereInput
  role: StringNullableFilter
  removedAt: DateTimeNullableFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: StringNullableFilter
}

input TeamMemberOrderByInput {
  id: OrderDirection
  role: OrderDirection
  removedAt: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

input TeamMemberUpdateInput {
  user: UserRelateToOneForUpdateInput
  team: TeamRelateToOneForUpdateInput
  role: String
  removedAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input TeamMemberUpdateArgs {
  where: TeamMemberWhereUniqueInput!
  data: TeamMemberUpdateInput!
}

input TeamMemberCreateInput {
  user: UserRelateToOneForCreateInput
  team: TeamRelateToOneForCreateInput
  role: String
  removedAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

type Team {
  id: ID!
  name: String
  description: String
  members(where: TeamMemberWhereInput! = {}, orderBy: [TeamMemberOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TeamMemberWhereUniqueInput): [TeamMember!]
  membersCount(where: TeamMemberWhereInput! = {}): Int
  events(where: EventWhereInput! = {}, orderBy: [EventOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: EventWhereUniqueInput): [Event!]
  eventsCount(where: EventWhereInput! = {}): Int
  createdAt: DateTime
}

input TeamWhereUniqueInput {
  id: ID
}

input TeamWhereInput {
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
  id: IDFilter
  name: StringFilter
  description: StringFilter
  members: TeamMemberManyRelationFilter
  events: EventManyRelationFilter
  createdAt: DateTimeNullableFilter
}

input TeamOrderByInput {
  id: OrderDirection
  name: OrderDirection
  description: OrderDirection
  createdAt: OrderDirection
}

input TeamUpdateInput {
  name: String
  description: String
  members: TeamMemberRelateToManyForUpdateInput
  events: EventRelateToManyForUpdateInput
  createdAt: DateTime
}

input TeamUpdateArgs {
  where: TeamWhereUniqueInput!
  data: TeamUpdateInput!
}

input TeamCreateInput {
  name: String
  description: String
  members: TeamMemberRelateToManyForCreateInput
  events: EventRelateToManyForCreateInput
  createdAt: DateTime
}

type Account {
  id: ID!
  user: User
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: DateTime
  token_type: String
  scope: String
  id_token: String
  session_state: String
  refresh_token_expires_at: DateTime
}

input AccountWhereUniqueInput {
  id: ID
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  id: IDFilter
  user: UserWhereInput
  type: StringFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringFilter
  access_token: StringFilter
  expires_at: DateTimeNullableFilter
  token_type: StringFilter
  scope: StringFilter
  id_token: StringFilter
  session_state: StringFilter
  refresh_token_expires_at: DateTimeNullableFilter
}

input AccountOrderByInput {
  id: OrderDirection
  type: OrderDirection
  provider: OrderDirection
  providerAccountId: OrderDirection
  refresh_token: OrderDirection
  access_token: OrderDirection
  expires_at: OrderDirection
  token_type: OrderDirection
  scope: OrderDirection
  id_token: OrderDirection
  session_state: OrderDirection
  refresh_token_expires_at: OrderDirection
}

input AccountUpdateInput {
  user: UserRelateToOneForUpdateInput
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: DateTime
  token_type: String
  scope: String
  id_token: String
  session_state: String
  refresh_token_expires_at: DateTime
}

input AccountUpdateArgs {
  where: AccountWhereUniqueInput!
  data: AccountUpdateInput!
}

input AccountCreateInput {
  user: UserRelateToOneForCreateInput
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: DateTime
  token_type: String
  scope: String
  id_token: String
  session_state: String
  refresh_token_expires_at: DateTime
}

type Event {
  id: ID!
  name: String
  starts_at: String
  type: String
  location: String
  createdBy: User
  team: Team
  published_at: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input EventWhereUniqueInput {
  id: ID
}

input EventWhereInput {
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
  id: IDFilter
  name: StringFilter
  starts_at: StringFilter
  type: StringNullableFilter
  location: StringFilter
  createdBy: UserWhereInput
  team: TeamWhereInput
  published_at: DateTimeNullableFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input EventOrderByInput {
  id: OrderDirection
  name: OrderDirection
  starts_at: OrderDirection
  type: OrderDirection
  location: OrderDirection
  published_at: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

input EventUpdateInput {
  name: String
  starts_at: String
  type: String
  location: String
  createdBy: UserRelateToOneForUpdateInput
  team: TeamRelateToOneForUpdateInput
  published_at: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input EventUpdateArgs {
  where: EventWhereUniqueInput!
  data: EventUpdateInput!
}

input EventCreateInput {
  name: String
  starts_at: String
  type: String
  location: String
  createdBy: UserRelateToOneForCreateInput
  team: TeamRelateToOneForCreateInput
  published_at: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createSession(data: SessionCreateInput!): Session
  createSessions(data: [SessionCreateInput!]!): [Session]
  updateSession(where: SessionWhereUniqueInput!, data: SessionUpdateInput!): Session
  updateSessions(data: [SessionUpdateArgs!]!): [Session]
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteSessions(where: [SessionWhereUniqueInput!]!): [Session]
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createTeamMember(data: TeamMemberCreateInput!): TeamMember
  createTeamMembers(data: [TeamMemberCreateInput!]!): [TeamMember]
  updateTeamMember(where: TeamMemberWhereUniqueInput!, data: TeamMemberUpdateInput!): TeamMember
  updateTeamMembers(data: [TeamMemberUpdateArgs!]!): [TeamMember]
  deleteTeamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  deleteTeamMembers(where: [TeamMemberWhereUniqueInput!]!): [TeamMember]
  createTeam(data: TeamCreateInput!): Team
  createTeams(data: [TeamCreateInput!]!): [Team]
  updateTeam(where: TeamWhereUniqueInput!, data: TeamUpdateInput!): Team
  updateTeams(data: [TeamUpdateArgs!]!): [Team]
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteTeams(where: [TeamWhereUniqueInput!]!): [Team]
  createAccount(data: AccountCreateInput!): Account
  createAccounts(data: [AccountCreateInput!]!): [Account]
  updateAccount(where: AccountWhereUniqueInput!, data: AccountUpdateInput!): Account
  updateAccounts(data: [AccountUpdateArgs!]!): [Account]
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteAccounts(where: [AccountWhereUniqueInput!]!): [Account]
  createEvent(data: EventCreateInput!): Event
  createEvents(data: [EventCreateInput!]!): [Event]
  updateEvent(where: EventWhereUniqueInput!, data: EventUpdateInput!): Event
  updateEvents(data: [EventUpdateArgs!]!): [Event]
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteEvents(where: [EventWhereUniqueInput!]!): [Event]
  endSession: Boolean!
  authenticateUserWithPassword(email: String!, password: String!): UserAuthenticationWithPasswordResult
  createInitialUser(data: CreateInitialUserInput!): UserAuthenticationWithPasswordSuccess!
}

union UserAuthenticationWithPasswordResult = UserAuthenticationWithPasswordSuccess | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String
  email: String
  password: String
}

type Query {
  sessions(where: SessionWhereInput! = {}, orderBy: [SessionOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SessionWhereUniqueInput): [Session!]
  session(where: SessionWhereUniqueInput!): Session
  sessionsCount(where: SessionWhereInput! = {}): Int
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  teamMembers(where: TeamMemberWhereInput! = {}, orderBy: [TeamMemberOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TeamMemberWhereUniqueInput): [TeamMember!]
  teamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  teamMembersCount(where: TeamMemberWhereInput! = {}): Int
  teams(where: TeamWhereInput! = {}, orderBy: [TeamOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TeamWhereUniqueInput): [Team!]
  team(where: TeamWhereUniqueInput!): Team
  teamsCount(where: TeamWhereInput! = {}): Int
  accounts(where: AccountWhereInput! = {}, orderBy: [AccountOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: AccountWhereUniqueInput): [Account!]
  account(where: AccountWhereUniqueInput!): Account
  accountsCount(where: AccountWhereInput! = {}): Int
  events(where: EventWhereInput! = {}, orderBy: [EventOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: EventWhereUniqueInput): [Event!]
  event(where: EventWhereUniqueInput!): Event
  eventsCount(where: EventWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
  isSingleton: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

enum KeystoneAdminUIFieldMetaIsNonNull {
  read
  create
  update
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

enum QueryMode {
  default
  insensitive
}

type KeystoneAdminUIFieldGroupMeta {
  label: String!
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
